======================
The Shapely 1.2 Manual
======================

:Author: Sean Gillies, <sean.gillies@gmail.com>
:Revision: 1.2
:Date: 1 March 2010
:Copyright: 
  This work is licensed under a `Creative Commons Attribution 3.0
  United States License`__.

.. __: http://creativecommons.org/licenses/by/3.0/us/

:Abstract: 
  This document explains how to use the Shapely Python package for
  computational geometry.

.. sectnum::

.. contents::


Introduction
============

Deterministic (non-statistical) spatial analysis is an important component of
computational approaches to problems in agriculture, ecology, epidemiology,
sociology, and many other fields. What is the surveyed perimeter/area ratio of
these patches of animal habitat? Which properties in this town intersect with
the 50-year flood contour from this new flooding model? What are the extents of
findspots for ancient ceramic wares with maker's marks "A" and "B", and where
do the extents overlap? These are just a few of the possible questions
addressable using deterministic spatial analysis, and more specifically,
computational geometry.

Shapely is a Python package for set-theoretic analysis and manipulation of
planar features using (via Python's `ctypes` module) functions from the well
known and widely deployed GEOS_ library. GEOS, a port of the `Java Topology
Suite`_, is the geometry engine of the PostGIS_ spatial extension for the
PostgreSQL RDBMS. The designs of JTS and GEOS are largely guided by the `Open
Geospatial Consortium`_'s Simple Features Access Specification [1]_ and Shapely
adheres mainly to the same set of standard classes and operations. Shapely is
deeply rooted in the geographic information systems (GIS) world, but aspires to
be equally useful to programmers working on non-tradtional problems.

PostGIS is a cornerstone of open source GIS, but isn't necessarily a solution
to all problems in the GIS domain. Not all geographic data originate or reside
in a RDBMS or are best processed using SQL. Shapely aims to bring industrial
strength computational geometry primitives to bear on programming problems
better addressed in a object-oriented style. Imagine a situation where we would
like to find or index a substring within another string. Is there overlap
between the strings, and if so, what is it?  Or maybe we'd like to replace
certain characters in a string with others. Now imagine that we're compelled to
load the text strings from, say, a log file into a relational database to
perform these operations because such string functions aren't available in a
non-SQL context. No knock on the RDBMS, a tremendously useful thing, but if
there's no mandate to manage (the "M" in "RDBMS") these strings over time in
the database, we're using the wrong tool for the job in this imaginary
scenario. Now, consider spatial entities like points, curves, and patches
instead of character strings, and that they might originate not in the context
of a traditional GIS, but from parsing and geocoding of texts or log files or
from "social web" activities. If you agree that sometimes PostGIS (or another
spatially-enabled RDBMS) is the wrong tool for your computational geometry job,
Shapely might be for you.

The premise of Shapely, or one of the premises, is that Python programmers
should be able to perform PostGIS type geometry operations outside of an RDBMS.
Another is that Python idioms trump GIS (or Java, in this case, since the GEOS
library is derived from JTS, a Java project) idioms. Shapely, in a nutshell
lets you do PostGIS-y stuff with geometries outside the context of a database
using idiomatic Python. Computational geometry, with no extra baggage.

Spatial Data Model
------------------

The fundamental types of features implemented by Shapely are: points, curves,
and surfaces. Each is associated with three sets of (possibly infinite) points
in the plane. The `interior`, `boundary`, and `exterior` sets of a feature are
mutually exclusive and their union coincides with the entire plane [2]_.

* A `Point` has an `interior` set of exactly one point, a `boundary` set of
  exactly no points, and an `exterior` set of all other points. A `Point` has
  a topological dimension of 0.

* A `Curve` has an `interior` set consisting of the infinitely many points
  along its length (imagine a `Point` dragged in space), a `boundary` set
  consisting of its two end points, and an `exterior` set of all other points.
  A `Curve` has a topological dimension of 1. 

* A `Surface` has an `interior` set consisting of the infinitely many points
  within (imagine a `Curve` dragged in space to cover an area), a `boundary`
  set consisting of one or more `Curves`, and an `exterior` set of all other
  points including those within holes that might exist in the surface. A
  `Surface` has a topological dimension of 2.

That may seem a bit esoteric, but will help clarify the meanings of Shapely's
spatial predicates, and it's as deep into theory as this manual will go.
Consquences of point-set theory, including some that manifest themselves as
"gotchas", for different classes will be discussed later in this manual.

The point type is implemented by a `Point` class; curve by the `LineString`
and `LinearRing` classes; and surface by a `Polygon` class. Shapely implements
no smooth (`i.e.` having continuous tangents) curves. All curves must be
approximated by linear splines. All rounded patches must be
approximated by regions bounded by linear splines.

Collections of points are implemented by a `MultiPoint` class, collections of
curves by a `MultiLineString` class, and collections of surfaces by a
`MultiPolygon` class. These collections aren't computationally significant, but
are useful for modeling certain kinds of features. A Y-shaped line feature, for
example, is well modeled as a whole by a `MultiLineString`.

The standard data model has additional constraints specific to certain types
of features that will be discussed in following sections of this manual.

See also http://www.vividsolutions.com/jts/discussion.htm#spatialDataModel
for more illustrations of this data model.

Relationships
-------------

The spatial data model is accompanied by a group of natural language
relationships among features – `contains`, `intersects`, `overlaps`, `touches`,
etc – and a theoretical framework for understanding them using the 3x3 matrix
of the mutual intersections of their component point sets [2]_: the DE-9IM. A
comprehensive review of the relationships in terms of the DE-9IM is found in
[4]_ and will not be reiterated in this manual.

Operations
----------

Following the JTS technical specs [5]_, this manual will make a distinction
between constructive (`buffer`, `convex hull`) and set-theoretic operations
(`intersection`, `union`, etc). The individual operations will be fully
described in a following section of the manual.

Coordinate Systems
------------------

Even though the Earth is not flat – and for that matter not exactly spherical –
there are many analytic problems that can be approached by transforming Earth
features to a Cartesian plane, applying tried and true algorithms, and then
transforming the results back to geographic coordinates.  This practice is as
old as the tradition of accurate paper maps.

Shapely does not support coordinate system transformations. All operations on
two or more features presume that the features exist in the same unitless
Cartesian plane.

Geometric Features and their Properties
=======================================

Features are created in the typical Python fashion, using the classes
themselves as instance factories. 

Instances of `Point`, `LineString`, and `LinearRing` have coordinate sequences.
Coordinate sequences are immutable. Their parent features are mutable in that
they can be assigned new coordinate sequences. A third `z` coordinate value may
be used when constructing features, but has no effect on geometric analysis.
All operations are performed in the `x-y` plane.

In all constructors, numeric values are converted to type `float`. In other
words, ``Point(0, 0)`` and ``Point(0.0, 0.0)`` produce geometrically equivalent
instances.

Pseudo-code blocks in this section will use the following notation. Let `a` be
a point in Cartesian coordinates, represented by a Python tuple of 2 (``(x,
y)``) or 3 (``(x, y, z)``) numerical values. Let `(a1, ..., aM)` and `(b1, ...,
bN)` be ordered sequences of `M` and `N` such points, defining the vertices of
a `curve`.

Points
------

The `Point` constructor takes a point tuple or positional coordinate value
parameters.

.. sourcecode:: pycon

  >>> from shapely.geometry import Point
  >>> p = Point((0.0, 0.0))
  >>> q = Point(0.0, 0.0)

A `Point` has zero area and zero length.

.. sourcecode:: pycon

  >>> p.area
  0.0
  >>> p.length
  0.0

Coordinate values are accessed via `coords`, `x`, `y`, and `z` properties.

.. sourcecode:: pycon

  >>> list(p.coords)
  [(0.0, 0.0)]
  >>> p.x
  0.0
  >>> p.y
  0.0

The `Point` constructor also accepts another `Point` instance, thereby making
a copy.

.. sourcecode:: pycon

  >>> Point(p)
  <shapely.geometry.point.Point object at 0x...>
  
LineStrings
-----------

The `LineString` constructor takes an ordered sequence of point tuples.

.. sourcecode:: pycon

  >>> from shapely.geometry import LineString
  >>> line = LineString((a1, ..., aM))

Repeating points in the ordered sequence are allowed, but may incur performance
penalties and should be avoided. A `LineString` may cross itself (*i.e.* be
`complex` and not `simple`).

A `LineString` has zero area and non-zero length.

.. sourcecode:: pycon

  >>> l = LineString([(0, 0), (1, 1)])
  >>> l.area
  0.0
  >>> l.length
  1.4142135623730951

Coordinate values are accessed via the `coords` property.

.. sourcecode:: pycon

  >>> len(l.coords)
  2
  >>> list(l.coords)
  [(0.0, 0.0), (1.0, 1.0)]

The `LineString` constructor also accepts another `LineString` instance,
thereby making a copy.

.. sourcecode:: pycon

  >>> LineString(l)
  <shapely.geometry.linestring.LineString object at 0x...>

A sequence of `Point` instances is not a valid constructor parameter.

LinearRings
-----------

The `LinearRing` constructor takes an ordered sequence of point tuples. The
sequence may be explicitly closed by passing identical values in the first and
last indices. Otherwise, the sequence will be implicitly closed.

.. sourcecode:: pycon

  >>> from shapely.geometry.polygon import LinearRing
  >>> ring = LinearRing((a1, ..., aM))

Repeating points in the ordered sequence are allowed, but may incur performance
penalties and should be avoided. A `LinearRing` may not cross itself, and may
not touch itself at a single point. Note that Shapely will not prevent the
creation of such rings, but exceptions will be raised when they are operated
on.

A `LinearRing` has zero area and non-zero length.

.. sourcecode:: pycon

  >>> r = LinearRing([(0, 0), (1, 1), (1, 0)])
  >>> r.area
  0.0
  >>> r.length
  3.4142135623730949

Coordinate values are accessed via the `coords` property.

.. sourcecode:: pycon

  >>> len(r.coords)
  4
  >>> list(r.coords)
  [(0.0, 0.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)]

The `LinearRing` constructor also accepts another `LineString` or `LinearRing`
instance, thereby making a copy.

.. sourcecode:: pycon

  >>> LinearRring(r)
  <shapely.geometry.polygon.LinearRing object at 0x...>
  
A sequence of `Point` instances is not a valid constructor parameter.

Polygons
--------

The `Polygon` constructor takes two positional parameters. The first is an
ordered sequence of point tuples and is treated exactly as in the `LinearRing`
case. The second is an optional unordered sequence of ring-like sequences
specifying the interior boundaries or "holes" of the feature.

.. sourcecode:: pycon

  >>> from shapely.geometry import Polygon
  >>> polygon = Polygon((a1, ..., aM), [(b1, ..., bN), ...])

`Polygon` rings may not cross each other, but may touch at single points.
Again,Shapely will not prevent the creation of such features, but exceptions
will be raised when they are operated on.

A `Polygon` has non-zero area and non-zero length.

.. sourcecode:: pycon

  >>> p = Polygon([(0, 0), (1, 1), (1, 0)])
  >>> p.area
  0.5
  >>> p.length
  3.4142135623730949

Component rings are accessed via `exterior` and `interiors` properties.

.. sourcecode:: pycon

  >>> list(p.exterior.coords)
  [(0.0, 0.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)]
  >>> list(p.interiors)
  []

The `Polygon` constructor also accepts instances of `LineString` and
`LinearRing`.

.. sourcecode:: pycon

  >>> xy = [(0, 0), (1, 1), (1, 0)]
  >>> r = LinearRing(xy)
  >>> s = Polygon(r)
  >>> s.area
  0.5  
  >>> t = Polygon(s.buffer(1.0).exterior, [r])
  >>> t.area
  6.5507620529190334

MultiPoints
-----------

The `MultiPoint` constructor takes an ordered sequence of point tuples.

.. sourcecode:: pycon

  >>> from shapely.geometry import MultiPoint
  >>> points = MultiPoint([c1, ..., cN])

Members of a multi-point collection are accessed via the `geoms` property.

.. sourcecode:: pycon

  >>> mp = MultiPoint([(0, 0), (1, 1)])
  >>> list(mp.geoms)
  [<shapely.geometry.point.Point object at 0x...>, <shapely.geometry.point.Point object at 0x...>]

The `MultiPoint` constructor also accepts an unordered sequence of `Point`
instances, thereby making copies.

.. sourcecode:: pycon

  >>> MultiPoint([Point(0, 0), Point(1, 1)])
  <shapely.geometry.multipoint.MultiPoint object at 0x...>

MultiLineStrings
----------------

A multi-line geometry is created by passing a sequence of representations of
lines

.. sourcecode:: python

  >>> from shapely.geometry import MultiLineString
  >>> lines = MultiLineString([(a1, ..., aM), (b1, ..., bN), ...])

MultiPolygons
-------------

A multi-polygon geometry is created by passing a sequence of exterior ring and
hole list tuples 

.. sourcecode:: python

  >>> from shapely.geometry import MultiPolygon
  >>> lines = MultiPolygon([((a1, ..., aM), [(b1, ..., bN), ...]), ...])

More explicit notation for the exterior and interior boundaries (or shells and
holes) makes usage more clear

.. sourcecode:: python

  >>> shell = (a1, ..., aM)
  >>> holes = [(b1, ..., bN), ...]
  >>> lines = MultiPolygon([(shell, holes), ...])

Null Geometries
---------------

Null geometries can be created by calling the factories with no arguments, but
almost nothing can be done with a null geometry.

.. sourcecode:: python

  >>> line_null = LineString()
  >>> line_null.length
  Traceback (most recent call last):
  ...
  ValueError: Null geometry supports no operations

The coordinates of a null geometry *can* be set (see Section 3), after which
the geometry is no longer null.

.. sourcecode:: python

  >>> l_null.coords = [(0, 0), (1, 1)]
  >>> print l_null.length
  1.414...


Constructive Operations
=======================

There are methods of geometry classes that also serve as factories for new
geometries. It is important to note that these are topological and not
point-wise operations, and therefore may produce results that are not what one
might expect from operations on Python sets.

See also the JTS |illustration2|_.

.. |illustration2| replace:: illustration
.. _illustration2: http://www.jump-project.org/project.php?PID=JTS&SID=OVER#spatialanalysismethods

Example Geometries
------------------

.. sourcecode:: python

  >>> polygon = Polygon(((-1.0, -1.0), (-1.0, 1.0), (1.0, 1.0), (1.0, -1.0)))
  >>> point_r = Point(-1.5, 1.2)
  >>> point_g = Point(-1.0, 1.0)
  >>> point_b = Point(-0.5, 0.5)
  >>> line_r = LineString(((-0.5, 0.5), (0.5, 0.5)))
  >>> line_g = LineString(((1.0, -1.0), (1.8, 0.5)))
  >>> line_b = LineString(((-1.8, -1.2), (1.8, 0.5)))

Buffer
------

.buffer(width, quadsegs=16) : geometry
  Returns a buffer region having the given width and with a specified number of
  segments used to approximate curves.
  
The default result of buffering a point is an N-gon approximation of a circle:

.. sourcecode:: python

  >>> buffered = point_r.buffer(1.0)
  >>> buffered
  <shapely.geometry.polygon.Polygon object at ...>
  >>> buffered.length
  6.2806623139097271
  >>> buffered.area
  3.1365484905463727
  >>> len(buffered.exterior.coords)
  66

Simplify
--------

.simplify(width, tolerance, preserve_topology=True) : geometry
  
  Returns a simplified version of the given geometry. All vertices in the
  simplified geometry will be within the `tolerance` distance of the original
  geometry. By default a slower algorithm is used that preserves topology. If
  preserve topology is set to False the much quicker Douglas-Peucker algorithm
  is used, and invalid geometries may result.
  
.. sourcecode:: python

  >>> p = Point(0.0, 0.0)
  >>> x = p.buffer(1.0)
  >>> x.area
  3.1365484905459389
  >>> len(x.exterior.coords)
  66
  >>> s = x.simplify(0.05, preserve_topology=False)
  >>> s.area
  3.0614674589207187
  >>> len(s.exterior.coords)
  17

Boundary
--------

.boundary : geometry
  Returns a lower dimension geometry. The boundary of a polygon is a line, the
  boundary of a line is a collection of points. The boundary of a point is an
  empty (null) collection.

.. sourcecode:: python

  >>> polygon.boundary
  <shapely.geometry.linestring.LineString object at ...>
  >>> line_b.boundary
  <shapely.geometry.multipoint.MultiPoint object at ...>
  >>> point_r.boundary.is_empty
  True

Centroid
--------

.centroid : geometry
  Returns the centroid, or geometric center of the polygon.

.. sourcecode:: python

  >>> centroid_point = polygon.centroid
  >>> centroid_point.wkt
  'POINT (-0.0000000000000000 -0.0000000000000000)'

Convex Hull
-----------

.convex_hull : geometry
  Imagine an elastic band stretched around the geometry: that's a convex hull,
  more or less.

For example, collect the three points into a multi-point geometry, and get the
triangular polygon that is their convex hull:

.. sourcecode:: python

  >>> multi_point = point_r.union(point_g)
  >>> multi_point = multi_point.union(point_b)
  >>> multi_point.convex_hull
  <shapely.geometry.polygon.Polygon object at ...>

Set-theoretic Operations
========================

Difference
----------

.difference(other) : geometry
  Returns a geometry representing the points making up this geometry that do
  not make up *other*. Note that A.difference(B) is not necessarily equal to
  B.difference(A).

.. sourcecode:: python

  >>> hull = multi_point.convex_hull
  >>> polygon.difference(hull)
  <shapely.geometry.polygon.Polygon object at ...>

Envelope
--------

.envelope : geometry
  Returns the geometry's rectangular polygon envelope.

.. sourcecode:: python

  >>> polygon.envelope
  <shapely.geometry.polygon.Polygon object at ...>

Intersection
------------

.intersection(other) : geometry
  Returns the intersection of one geometry and the *other* geometry.

.. sourcecode:: python

  >>> polygon.intersection(hull)
  <shapely.geometry.polygon.Polygon object at ...>

Symmetric Difference
--------------------

.symmetric_difference(other) : geometry
  Returns a geometry combining the points in this geometry not in *other*, and
  the points in *other* not in this geometry.

.. sourcecode:: python

  >>> polygon.symmetric_difference(hull)
  <shapely.geometry.multipolygon.MultiPolygon object at ...>

Union
-----

.union(other) : geometry
  Returns the union of one geometry and the *other* geometry.

Point unions were demonstrated above under convex hull. The union of polygons
will be a polygon or a multi-polygon depending on whether they intersect or
not:

.. sourcecode:: python

  >>> hull.union(polygon)
  <shapely.geometry.polygon.Polygon object at ...>


Other Operations
================

Polygonization
--------------

shapely.ops.polygonize(lines) : iterator
  Returns an iterator over polygons constructed from the *lines* iterator. The
  elements of *lines* may be Shapely geometries, objects that provide the geo
  interface, or Numpy arrays or Python sequences shaped like LineStrings.

.. sourcecode:: python

  >>> from shapely.ops import polygonize
  >>> lines = [
  ...     ((0, 0), (1, 1)),
  ...     ((0, 0), (0, 1)),
  ...     ((0, 1), (1, 1)),
  ...     ((1, 1), (1, 0)),
  ...     ((1, 0), (0, 0))
  ...     ]
  >>> result = polygonize(lines)
  >>> list(result.geoms)
  [<shapely.geometry.polygon.Polygon object at ...>, <shapely.geometry.polygon.Polygon object at ...>]

Line merging
------------

shapely.ops.linemerge(lines) : iterator or MultiLineString
  Merges all connected lines. Returns a LineString or MultiLineString when
  lines are not contiguous. 

.. sourcecode:: python

  >>> lines = MultiLineString([ 
  ...     ((0, 0), (1, 1)), 
  ...     ((2, 0), (2, 1), (1, 1)) 
  ...     ]) 
  >>> result = linemerge(lines)
  >>> result # docstring: +ELLIPSIS
  <shapely.geometry.linestring.LineString object at 0x...>


Unary Spatial Predicates
========================

These are implemented as Python attributes.

Is Empty
--------

.is_empty : bool
  True if the set of points in this geometry is empty, else False. For more
  details, see
  http://geos.refractions.net/ro/doxygen_docs/html/classgeos_1_1geom_1_1Geometry.html#a17.  

Is Valid
--------

.is_valid : bool
  True if the geometry is valid (definition depends on sub-class), else False.
  For more details, see
  http://geos.refractions.net/ro/doxygen_docs/html/classgeos_1_1geom_1_1Geometry.html#a16.

Is Ring
-------

.is_ring : bool
  True if the geometry is a closed ring, else False.

Has Z
-----

.has_z : bool
  True if the geometry's coordinate sequence(s) have z values (are
  3-dimensional)

Examples
--------

.. sourcecode:: python

  >>> polygon.is_empty
  False
  >>> polygon.is_valid
  True
  >>> polygon.is_ring
  False
  >>> polygon.boundary.is_ring
  True
  >>> polygon.has_z
  False

(Note: that last return value exposes a bug in GEOS 2.2.3.)


Binary Spatial Predicates
=========================

All of these methods take a single positional argument, an *other* geometry. It
is important to note that these are topological and not point-wise operations,
and therefore may produce results that are not what one might expect from
operations on Python.

Contains
--------

.contains(other) : bool
  True if the geometry is spatially within, without touching. Applies to all
  types of geometries.

.. sourcecode:: python

  >>> polygon.contains(point_b)
  True

Crosses
-------

.crosses(other) : bool
  Only linear geometries (lines, rings, polygon boundaries) may ever cross. No
  geometry may ever cross a point.

.. sourcecode:: python

  >>> line_b.crosses(polygon)
  True

Disjoint
--------

.disjoint(other) : bool
  True if geometries do not spatially relate in any way, else False. See the
  complementary *intersects*. 

.. sourcecode:: python

  >>> polygon.disjoint(point_r)
  True

Equals
------

.equals(other) : bool
  Two geometries are topologically equal if their interiors intersect and no
  part of the interior or boundary of one geometry intersects the exterior of
  the other. Not to be confused with Python's *__equals__*.

Intersects
----------

.intersects(other) : bool
  This predicate is the complement of *disjoint*: geometries that do not
  intersect are disjoint. Intersects is the most inclusive predicate.

.. sourcecode:: python

  >>> polygon.intersects(point_b)
  True

Touches
-------

.touches(other) : bool
  True if geometries *only* touch. The least inclusive predicate.

.. sourcecode:: python

  >>> polygon.touches(line_g)
  True
  >>> polygon.touches(line_b)
  False

Within
------

.within(other): bool
  The inverse of *contains*.


General Methods
===============

Distance
--------

.distance(other) : geometry
  The minimum distance from one geometry to the other.

.. sourcecode:: python

  >>> Point(0,0).distance(Point(1,1))
  1.4142135623730951


Scalar Properties
=================

Area
----

.area : float
  Area of the geometry, unitless. Non-zero only for surfaces (polygons,
  multi-polygons).

Bounds
------

.bounds : tuple
  The geometry's (minx, miny, maxx, maxy) bounding box.

Length
------

.length : float
  Length of the geometry, unitless. Non-zero only for linear geometries
  (line strings, rings, polygon boundaries)

Examples
--------

.. sourcecode:: python

  >>> polygon.area
  4.0
  >>> polygon.bounds
  (-1.0, -1.0, 1.0, 1.0)
  >>> polygon.length
  8.0
  >>> line_r.length
  1.0
  >>> line_b.length
  3.9812058474788765


Geometry Parts and Coordinates
==============================

Coordinate Sequences
--------------------

The coordinates of points, line strings, and polygon rings can be accessed
through the *coords* attribute of a geometry. *Coords* is an iterator over
coordinate tuples.

.. sourcecode:: python

  >>> point_r.coords
  <shapely.geometry.base.CoordinateSequence object at ...>
  >>> len(point_r.coords)
  1
  >>> point_r.coords[0]
  (-1.5, 1.2)
  >>> list(point_r.coords)
  [(-1.5, 1.2)]

The coordinate sequence can be modifed by assigning a sequence (**a**\ 1, ...,
**a**\ M) to the coords attribute.

.. sourcecode:: python

  >>> point_new = Point(0, 0)
  >>> point_new.coords = (1, 1)
  >>> list(point_new.coords)
  [(1.0, 1.0)]

For line strings:

.. sourcecode:: python

  >>> line_new = LineString([(0,0), (1,1)])
  >>> line_new.coords = [(1,1), (2,2)]
  >>> list(line_new.coords)
  [(1.0, 1.0), (2.0, 2.0)]


Polygon Rings
-------------

The exterior boundary of a polygon can be accessed through the *exterior*
attribute of the geometry object.

.. sourcecode:: python

  >>> polygon.exterior
  <shapely.geometry.polygon.LinearRing object at ...>
  >>> list(polygon.exterior.coords)
  [(-1.0, -1.0), (-1.0, 1.0), (1.0, 1.0), (1.0, -1.0), (-1.0, -1.0)]

The interior boundaries (or holes) of a polygon can be accessed through the
*interiors* attribute, which is a list of rings.


Sub-geometries
--------------

The parts of a multi-part geometry can be accessed through the *geoms*
attribute of the geometry object, which is an iterator over the sub-geometries:

.. sourcecode:: python

  >>> multi_point.geoms
  <shapely.geometry.base.GeometrySequence object at ...>
  >>> len(multi_point.geoms)
  3
  >>> from pprint import pprint
  >>> pprint(list(multi_point.geoms))
  [<shapely.geometry.point.Point object at ...>,
   <shapely.geometry.point.Point object at ...>,
   <shapely.geometry.point.Point object at ...>]

The coordinate sequences of these sub-geometries can then be accessed as
described above.


Point Coordinates
-----------------

For the sake of convenience the coordinate values of points can be accessed
read-only via **x**, **y**, and **z** attributes:

.. sourcecode:: python

  >>> point = Point(1.0, 1.0)
  >>> point.x
  1.0
  >>> point.y
  1.0


Interoperation
==============

Shapely provides 4 avenues for interoperation with other Python and GIS
software.

Well-known Formats
------------------

Well-known Text (WKT)
+++++++++++++++++++++

The WKT representation of any geometry object can be had via the **wkt**
attribute:

.. sourcecode:: python

  >>> point_r.wkt
  'POINT (-1.5000000000000000 1.2000000000000000)'

Hex-encode that string and you have a value that can be conveniently inserted directly into PostGIS

.. sourcecode:: python

  >>> point_r.wkt.encode('hex')
  '504f494e5420282d312e3530303030303030303030303030303020312e3230303030303030303030303030303029'

New geometries can be created from WKT representations using the
*shapely.wkt.loads* factory (inspired by the *pickle* module) 

.. sourcecode:: python

  >>> from shapely.wkt import loads
  >>> loads('POINT (0 0)')
  <shapely.geometry.point.Point object at ...>

Well-known Binary (WKB)
+++++++++++++++++++++++

The WKB representation of any geometry object can be had via the **wkb**
attribute. New geometries can be created from WKB data using the
*shapely.wkb.loads* factory. Use this format to interoperate with ogr.py:

.. sourcecode:: python

  >>> import ogr
  >>> from shapely.wkb import loads
  >>> source = ogr.Open("/tmp/world_borders.shp")
  >>> borders = source.GetLayerByName("world_borders")
  >>> feature = borders.GetNextFeature()
  >>> loads(feature.GetGeometryRef().ExportToWkb())
  <shapely.geometry.polygon.Polygon object at ...>


Python Sequences
----------------

Python sequence data can be analyzed as Shapely geometries using the
*shapely.geometry.as\** adapters while leaving the data in its original
storage. A pair of float can be treated as a point with **asPoint**:

.. sourcecode:: python

  >>> from shapely.geometry import asPoint
  >>> coords = [3.0, 4.0]
  >>> pa = asPoint(coords)
  >>> pa.wkt
  'POINT (3.0000000000000000 4.0000000000000000)'

Move the coordinates and watch the geometry adapter change

.. sourcecode:: python

  >>> coords[0] = 1.0
  >>> pa.wkt
  'POINT (1.0000000000000000 4.0000000000000000)'

The **asLineString** adapter works much the same. The **asPolygon** adapter is
used like

.. sourcecode:: python

  >>> from shapely.geometry import asPolygon
  >>> coords = [[0.0, 0.0], [0.0, 1.0], [1.0, 1.0], [1.0, 0.0]]
  >>> hole_coords = [((0.1,0.1), (0.1,0.2), (0.2,0.2), (0.2,0.1))]
  >>> pa = asPolygon(coords, hole_coords)
  >>> len(pa.exterior.coords)
  5
  >>> len(pa.interiors)
  1
  >>> len(pa.interiors[0].coords)
  5


Numpy Array Interface
---------------------

Shapely geometries provide the Numpy array interface which means that points,
line strings, and polygon rings can be used as Numpy arrays:

.. sourcecode:: python

  >>> from numpy import array
  >>> a = array(polygon.exterior)
  >>> a
  array([[-1., -1.],
         [-1.,  1.],
         [ 1.,  1.],
         [ 1., -1.],
         [-1., -1.]])

The *numpy.asarray* function does not copy coordinate values at the price of
slower numpy access to coordinates.

The *shapely.geometry.as\** functions can also be used to wrap numpy arrays,
which can then be analyzed using Shapely while maintaining their original
storage. A 1 x 2 array can be adapted to a point

.. sourcecode:: python

  >>> a = array([1.0, 2.0])
  >>> pa = asPoint(a)
  >>> pa.wkt
  'POINT (1.0000000000000000 2.0000000000000000)'

and a N x 2 array can be adapted to a line string

.. sourcecode:: python

  >>> from shapely.geometry import asLineString
  >>> a = array([[1.0, 2.0], [3.0, 4.0]])
  >>> la = asLineString(a)
  >>> la.wkt
  'LINESTRING (1.0000000000000000 2.0000000000000000, 3.0000000000000000 4.0000000000000000)'

There is no Numpy array representation of a polygon.


Python Geo Interface
--------------------

Any object that provides the GeoJSON-like `Python geo interface`_ can be
adapted and used as a Shapely geometry using the *shapely.geometry.asShape*
function. For example, a dictionary:

.. sourcecode:: python

  >>> from shapely.geometry import asShape
  >>> d = {"type": "Point", "coordinates": (0.0, 0.0)}
  >>> shape = asShape(d)
  >>> shape.geom_type
  'Point'
  >>> list(shape.coords)
  [(0.0, 0.0)]

Or a simple placemark-type object:

.. sourcecode:: python

  >>> class GeoThing(object):
  ...     def __init__(self, d):
  ...         self.__geo_interface__ = d
  >>> thing = GeoThing({"type": "Point", "coordinates": (0.0, 0.0)})
  >>> shape = asShape(thing)
  >>> shape.geom_type
  'Point'
  >>> list(shape.coords)
  [(0.0, 0.0)]

If you want to copy coordinate data to a new geometry, use the
*shapely.geometry.shape* function instead.

.. _Python geo interface: http://trac.gispython.org/projects/PCL/wiki/PythonGeoInterface


Advanced Features
=================

Iterative Operations
--------------------

Shapely provides functions for efficient operations on large sets of
geometries.

Contains
++++++++

To find the subset of points that are contained within a polygon, use
*shapely.iterops.contains*:

.. sourcecode:: python

  >>> from shapely.geometry import Polygon
  >>> from shapely.geometry import Point
  >>> coords = ((0.0, 0.0), (0.0, 1.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0))
  >>> polygon = Polygon(coords)
  >>> points = [Point(0.5, 0.5), Point(2.0, 2.0)]  
  >>> from shapely import iterops  
  >>> list(iterops.contains(polygon, points, True))
  [<shapely.geometry.point.Point object at ...>]

The second parameter to *iterops.contains* can be any kind of iterator, even a
generator of objects. If it yields tuples, then the second element of the tuple
will be ultimately yielded from *iterops.contains*.

.. sourcecode:: python

  >>> list(iterops.contains(polygon, iter((p, p.wkt) for p in points)))
  ['POINT (0.5000000000000000 0.5000000000000000)']

Prepared Geometry Operations
----------------------------

Shapely geometries can be pre-analyzed into a state that supports more
efficient batches of operations. To test one polygon containment against a
large batch of points, one should first use the `prepared.prep` function:

.. sourcecode:: python

  >>> from shapely.geometry import Point
  >>> from shapely.prepared import polyprep
  >>> points = [...] # large list of points
  >>> polygon = Point(0.0, 0.0).buffer(1.0)
  >>> prepared_polygon = prep(polygon)
  >>> prepared_polygon
  <shapely.prepared.PreparedGeometry object at ...>
  >>> hits = filter(prepared_polygon.contains, points)

Prepared geometries instances have the following methods: ``contains``,
``contains_properly``, ``covers``, and ``intersects``. All have exactly the
same arguments and usage as their counterparts in the standard geometries.

Credits
=======

Shapely is written by Sean Gillies with contributions from Aron Bierbaum,
Howard Butler, Kai Lautaportti (Hexagon IT), Frédéric Junod (Camptocamp SA),
Eric Lemoine (Camptocamp SA) and ctypes tips from Justin Bronn (GeoDjango).

.. _GEOS: http://geos.refractions.net
.. _Java Topology Suite: http://www.vividsolutions.com/jts/jtshome.htm
.. _PostGIS: http://postgis.refractions.net
.. _record: http://pypi.python.org/pypi/Shapely
.. _wiki: http://trac.gispython.org/lab/wiki/Shapely
.. _Open Geospatial Consortium: http://wwww.opengeospatial.org/
.. _Davis: http://lin-ear-th-inking.blogspot.com/2007/06/subtleties-of-ogc-covers-spatial.html
.. _Understanding spatial relations: http://edndoc.esri.com/arcsde/9.1/general_topics/understand_spatial_relations.htm
.. _Strobl-PDF: http://gis.hsr.ch/wiki/images/3/3d/9dem_springer.pdf
.. |Strobl-PDF| replace:: PDF
.. _JTS-PDF: http://www.vividsolutions.com/jts/bin/JTS%20Technical%20Specs.pdf
.. |JTS-PDF| replace:: PDF

References
==========

.. [1] John R. Herring, Ed.,
   “OpenGIS Implementation Specification for Geographic information - Simple
   feature access - Part 1: Common architecture,” Oct. 2006.

.. [2] M.J. Egenhofer and John R. Herring, 
   Categorizing Binary Topological Relations Between Regions, Lines, and Points
   in Geographic Databases,  Orono, ME: University of Maine, 1991.

.. [3] E. Clementini, P. Di Felice, and P. van OOsterom,
   “A Small Set of Formal Topological Relationships Suitable for End-User
   Interaction,” Third International Symposium on Large Spatial Databases
   (SSD). Lecture Notes in Computer Science no. 692, David Abel and Beng Chin
   Ooi, Eds.,  Singapore: Springer Verlag, 1993, pp. 277-295.

.. [4] C. Strobl, “Dimensionally Extended Nine-Intersection Model (DE-9IM),”
   Encyclopedia of GIS, S. Shekhar and H. Xiong, Eds.,
   Springer, 2008, pp. 240-245. [|Strobl-PDF|_]

.. [5] Martin Davis, “JTS Technical Specifications,” Mar. 2003. [|JTS-PDF|_]

